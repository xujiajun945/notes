# 微服务架构中的分布式事务

## 前言

​		在传统单体应用演变为分布式架构后, 解决了许多单体应用存在的痛点, 例如扩展性差, 可维护性差, 数据库性能瓶颈等问题, 但是分布式的架构同样为我们带来了新的痛点, 系统复杂度变高, 开发调试起来更加的困难, 同时引入了分布式事务, 分布式锁, 链路追踪等等问题, 最近一段时间学习了有关分布式事务的知识, 现对其做如下总结

## 什么是分布式事务

​		在传统的单体应用中, 事务我们已经非常熟悉, 对于我们的业务操作, 由于在jvm中处于同一线程执行, 数据库本地事务可以方便的对我们的操作进行提交或者回滚

​		在分布式系统中, 微服务之间采用rpc的调用方式, 服务与服务之间彼此互相独立, 相互调用, 而服务本身具有自己的本地事务, 这样, 我们调用方的本地的事务无法对调用方的本地事务操作判断其提交或者回滚, 于是分布式事务就产生了

### 分布式系统的CAP理论

#### <font color="red">一致性(**Consistency**)</font>

#### <font color="red">可用性(**Availability**)</font>

#### <font color="red">分区容错性(**Partition Tolerance**)</font>

​		<u>CAP理论: 分布式系统只能同时满足一致性, 可用性, 分区容错性中的两种, 无法三者兼得</u>

## 分布式事务的解决方案

​		目前主流的分布式事务的解决方案有如下几种:

### XA协议

​		XA协议是**<font color="red">基于数据库本身</font>**的一种分布式事务解决方案, 其实现为**2PC(二阶段提交)**, 还有基于2PC的改良**3PC(三阶段提交)**, 简单介绍一下这两种方式:

#### 2PC(二阶段提交)

​		在分布式事务中, 2PC将各个本地事务称之为分布式事务的***<font color="blue">参与者</font>***, 而除了参与者外, 还需要一个***<font color="blue">协调者</font>***, 协调者用来整体控制参与者的事务提交或回滚. 二阶段提交, 顾名思义, 就是将事务的提交分为了两个阶段, 其流程如下:

##### 第一阶段: 请求/投票阶段

​		![](img/2PC-第一阶段.png)

​		协调者向参与者发起事务执行命令, 所有参与者执行事务, 执行后返回执行的状态(成功/失败), 并**锁定资源不提交事务, 进入等待状态**



##### 第二阶段: 执行(commit/rollback)阶段

​		![](img/2PC-第二阶段.png)

​		根据第一阶段参与者的返回状态, 向所有参与者发送提交/回滚指令, 当全部参与者返回成功时, 发送提交指令, 否者发送回滚指令



​		由上述流程可知, 2PC是一种**<font color="red">强一致性的解决方案</font>**, 但是2PC有着如下的缺点:

1. 该解决方案中, 所有的参与者都是阻塞式的, 参与者的事务最终提交与否, 必须等待协调者接受全部参与者的返回状态后发送的指令, 在此期间, 线程是阻塞等待的, 造成其**性能低下**
2. **没有超时机制**: 在第一阶段结束后, 如果协调者发生故障, 或者部分参与者由于网络波动等原因并没有接收到协调者的第二阶段指令, 其事务将会一直处于等待状态
3. **并没有完全的解决数据一致性的问题**: 当第一阶段所有参与者返回成功, 协调者发起提交指令, 如发生2所说情况, 部分参与者提交本地事务, 而部分参与者没有提交, 产生了数据一致性问题



#### 3PC(三阶段提交)

​		由于二阶段提交的问题, 由此产生了3PC, 3PC目前可能只是一个理论上的方案, 并没有发现其最终实现, 所谓三阶段提交, 就是在原有的二阶段提交的第一阶段基础上, 扩展了一个预提交状态, 同时对全局引入了***超时机制***, 其具体细节如下:

##### 第一阶段: canCommit阶段

![](img/3PC-canCommit阶段.png)

​		协调者发送canCommit指令, 各个参与者检查其事务能否提交(例如能否获取到锁)



##### 第二阶段: preCommit阶段

![](img/3PC-preCommit阶段.png)

​		协调者发送preCommit指令, 各个参与者开始执行事务, 但不提交, 发送执行的结果状态



##### 第三阶段: doCommit阶段

![](img/3PC-doCommit阶段.png)

​		协调者向所有参与者发送doCommit指令



​		三阶段提交在二阶段提交的基础上, 增加了一个阶段, 同时增加了超时机制, 即: **参与者, 在超过指定时间后, 将会自动<font color="red">提交</font>, 协调者在<font color="red">第一阶段和第二阶段</font>超时未接受到参与者响应, 将全局发送<font color="red">abort(回滚)</font>指令, 协调者在<font color="red">第三阶段</font>超时未接收到参与者回应, 将全局发送<font color="red">commit(提交)</font>指令(这个应该是基于概率的, 当进入第三阶段了, 我们有理由相信提交结果成功)**

​		三阶段提交其实并没有完全解决数据一致性的问题, 而且由于XA协议的阻塞性, 因此, **<font color="green">互联网公司一般不采用该方案</font>**



### TCC补偿型事务

​		补偿型事务(TCC)是 Try - Comfirm - Cancel 三个单词的首字符缩写, 其实现是***基于2PC***的, 是一种**<font color="red">业务层的分布式事务解决方案</font>**, 对需要进行补偿型事务的业务, 每个本地事务都需要实现 **Try & Comfirm & Cancel** 三个接口, 其具体步骤如下:

​		